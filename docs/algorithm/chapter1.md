# 数据结构
数据结构主要有：
- 数组
- 栈
- 队列
- 链表
- 树（二叉树）

## 数组
数组即是 js 中的数组概念，不多叙述，这里主要提一下二维数组，在 js 中二维数组等价于 “矩阵” 的概念，所以在 js 算法题中，见到 “矩阵” 时不要慌，它就是二维数组。

## 栈（Stack）
栈是一种 **后进先出（LIFO，Last In First Out）** 的数据结构，在 JavaScript 中，栈的实现要依赖于数组，换句话说就是 **栈在 JavaScript 中是一种只用 pop 和 push 完成增删的数组**。

“后进先出“ 的特征限定了只能从数组的尾部进行操作，即 `pop` 用于删除尾部元素，`push` 用于在尾部添加元素。而另一个概念 “栈顶元素”，在这里表示的也就是数组的尾部元素。

代码演示栈：
```js
// 初始状态，栈空
const stack = []  
// 入栈过程
stack.push(1)
stack.push(2)
stack.push(3)
stack.push(4)
stack.push(5)

// 出栈过程，栈不为空时才执行
while(stack.length) {
    // 单纯访问栈顶元素（不出栈）
    const top = stack[stack.length-1]
    // 将栈顶元素出栈
    stack.pop()
}

// 栈空
stack // []
```
## 队列（Queue）
队列是一种 **先进先出（FIFO，First In First Out）** 的数据结构，与栈一样，队列的实现也要依赖数组，**队列在 JavaScript 中是一种只用 shift 和 push 完成增删的数组**。

“先进先出” 的特征也很明显，就是在数组尾部用 `push` 添加元素，在数组头部用 `shift` 删除元素。

代码演示队列：
```js
const queue = []  
queue.push(1)
queue.push(2)
queue.push(3)  
  
while(queue.length) {
    // 单纯访问队头元素（不出队）
    const top = queue[0]
    // 将队头元素出队
    queue.shift()
}

// 队空
queue // []
```

## 链表
链表和数组类似，它们都是有序的列表，都是线性结构。不同点在于，链表中的数据单位的名称叫做 “结点”，结点和结点在内存中的分布是**离散**的。

“离散”是相对于数组的“连续”来说的，数组在内存中是一段连续的内存空间，即元素与元素之间紧紧相连，每一个元素可以通过索引下标直接定位。

链表中的元素与元素之间不像在数组中那样，哪怕知道了元素1的坑位，也不知道排在它后面的到底是谁，对于这种离散的内存状态，我们需要手动建立元素与元素之间的关联，让它们以线性排列。

在链表中，每一个结点的结构都包括了两部分的内容：**数据域** 和 **指针域**。JS 中的链表，是以嵌套的对象的形式来实现：
```js
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val: 2,
        next: ...
    }
}
```
数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了线性关联。

### 链表结点的创建
使用构造函数创建结点：
```js
function ListNode(val) {
    this.val = val
    this.next = null
}
```
```js
const node = new ListNode(1)
node.next = new ListNode(2)
```
### 插入链表结点
如果直接在尾部添加，那相对比较简单，就如上面代码一样，尾部结点的 next 指针指向新增的结点即可。这里考虑的是怎么在两个结点之间插入一个新的结点，假设已有两个结点：
```js
// 结点1
const node1 = new ListNode(1)
// 结点1的 next 指向结点2
node1.next = new ListNode(2)
```
现在要在 node1 和 node2 之间插入 node3，本质上就是改变 node1 的 next 指向到 node3 上，而 node3 的 next 指向 node2，用代码表示即是：
```js
// 创建结点3
const node3 = new ListNode(3)
// node1.next 指向的是 node2，现将 node2 挂到 node3.next 上
node3.next = node1.next
// node1.next 改为指向 node3
node1.next = node3
```
现在它们的链接顺序就是 node1 -> node3 -> node2

### 删除链表结点
删除结点的本质是在遍历链表的过程中无法遍历到这个结点，按照这个逻辑，如果我们想要删除 node3，只要将 node1 的 next 跳过 node3，直接指向 node3 的后继，即指向 node2 就行了。如此一来，node3 就成了一个完全不可抵达的结点，它就会被 JS 的垃圾回收器自动回收掉。

用代码演示删除 node3 的过程：
```js
node1.next = node3.next
```
没错，就是这么简单。其实我们可以只用一个指针，这里我们只需要拿到 node1 即可：
```js
// node1.next 本指向的就是 node3
const target = node1.next
node1.next = target.next
```

## 链表和数组的辨析
首先要说的是“JS中的数组未必是真正的数组”。数组的定义中，有一个必要条件就是“存储在连续的内存空间里”，然而 JS 中的数组不一定满足这个条件。如果数组中只定义了一种类型的元素，比如：
```js
const arr = [1, 2, 3, 4, 5]
```
它是一个纯数字数组，那么对应的确实是连续内存。
但如果定义了不同类型的元素：
```js
const arr = ['hello', 1, {a: 2}]
```
它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层其实是由链表来实现的。

### 访问效率对比
访问数组元素很简单，只需要拿到索引直接访问即可，如 `arr[2]`，这个操作的复杂度是常数级别的（O(1)）。但是访问链表结点时就比较麻烦了，当我们要读取某一个特定的结点时，需要遍历整个链表来查找它，比如要在一个长度为 n（n>10）的链表里，定位它的第10个结点，就需要这样做：
```js
// 目标结点的位置
const idx = 10
// 设一个游标指向链表第一个结点，从第一个结点开始遍历
let node = head 
// 反复遍历到第10个结点为止
for(let i=0;i<index&&node;i++) {
    node = node.next
}
```
随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。

### 增删效率对比
真正的数组都对应着一段连续的内存，如果要删除任意位置的一个元素，那么该元素后面的所有元素都要往前挪一个位置；相应地如果是添加元素，那么该元素后面的元素都要往后挪一个位置。

**我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。**

而在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。

## 二叉树
二叉树是树形数据结构中的一种，它要满足以下要求：
- 它可以没有根节点，作为一棵空树存在
- 如果不是空树，那么**必须由根节点、左子树和右子树组成，且左右子树都是二叉树**，如下图：
<img :src="$withBase('/algorithm/tree.png')" alt="tree">

**二叉树不能被简单定义为每个结点的度都是2的树**。二叉树中左右子树的位置是严格约定不能交换的，即 B 和 C、D 和 E、F 和 G 是不能互换的。
> 什么是度？一个结点开叉出去多少个子树，就被记为结点的“度”。二叉树中除了叶子结点，其他结点的度都为2。叶子结点表示的是没有开叉的结点。

### JS 实现二叉树
在 JS 中，二叉树使用对象来定义，结构分为三部分：
- 数据域
- 左侧子结点（左子树根结点）的引用
- 右侧子结点（右子树根结点）的引用

使用构造函数方式定义二叉树：
```js
function TreeNode(val) {
    this.val = val
    this.left = this.right = null
}
```
当需要创建二叉树结点时：
```js
const node = new TreeNode(1)
```