<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>数据结构 | awesome-record</title>
    <meta name="description" content="个人记录">
    <meta name="generator" content="VuePress 1.4.0">
    
    
    <link rel="preload" href="/awesome-record/assets/css/0.styles.049fb93f.css" as="style"><link rel="preload" href="/awesome-record/assets/js/app.4bf2a835.js" as="script"><link rel="preload" href="/awesome-record/assets/js/2.0fcb112f.js" as="script"><link rel="preload" href="/awesome-record/assets/js/6.8680ebb7.js" as="script"><link rel="prefetch" href="/awesome-record/assets/js/10.792d8d51.js"><link rel="prefetch" href="/awesome-record/assets/js/11.cb3dd52c.js"><link rel="prefetch" href="/awesome-record/assets/js/12.78cf05a8.js"><link rel="prefetch" href="/awesome-record/assets/js/3.54d189f4.js"><link rel="prefetch" href="/awesome-record/assets/js/4.5f60d4ea.js"><link rel="prefetch" href="/awesome-record/assets/js/5.3ae4be87.js"><link rel="prefetch" href="/awesome-record/assets/js/7.6b3e23e2.js"><link rel="prefetch" href="/awesome-record/assets/js/8.14ebd268.js"><link rel="prefetch" href="/awesome-record/assets/js/9.f20eca1a.js">
    <link rel="stylesheet" href="/awesome-record/assets/css/0.styles.049fb93f.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/awesome-record/" class="home-link router-link-active"><!----> <span class="site-name">awesome-record</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/awesome-record/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/awesome-record/algorithm/chapter1.html" class="nav-link router-link-exact-active router-link-active">
  算法
</a></div><div class="nav-item"><a href="/awesome-record/blog/vue.html" class="nav-link">
  Blog
</a></div> <a href="https://github.com/wungjyan/awesome-record" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/awesome-record/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/awesome-record/algorithm/chapter1.html" class="nav-link router-link-exact-active router-link-active">
  算法
</a></div><div class="nav-item"><a href="/awesome-record/blog/vue.html" class="nav-link">
  Blog
</a></div> <a href="https://github.com/wungjyan/awesome-record" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS 中的算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/awesome-record/algorithm/chapter1.html" class="active sidebar-link">数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#数组" class="sidebar-link">数组</a></li><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#栈（stack）" class="sidebar-link">栈（Stack）</a></li><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#队列（queue）" class="sidebar-link">队列（Queue）</a></li><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#链表" class="sidebar-link">链表</a></li><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#链表和数组的辨析" class="sidebar-link">链表和数组的辨析</a></li><li class="sidebar-sub-header"><a href="/awesome-record/algorithm/chapter1.html#二叉树" class="sidebar-link">二叉树</a></li></ul></li><li><a href="/awesome-record/algorithm/chapter2.html" class="sidebar-link">遍历二叉树</a></li><li><a href="/awesome-record/algorithm/chapter3.html" class="sidebar-link">数组相关算法题</a></li><li><a href="/awesome-record/algorithm/chapter4.html" class="sidebar-link">字符串相关算法题</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="数据结构"><a href="#数据结构" class="header-anchor">#</a> 数据结构</h1> <p>数据结构主要有：</p> <ul><li>数组</li> <li>栈</li> <li>队列</li> <li>链表</li> <li>树（二叉树）</li></ul> <h2 id="数组"><a href="#数组" class="header-anchor">#</a> 数组</h2> <p>数组即是 js 中的数组概念，不多叙述，这里主要提一下二维数组，在 js 中二维数组等价于 “矩阵” 的概念，所以在 js 算法题中，见到 “矩阵” 时不要慌，它就是二维数组。</p> <h2 id="栈（stack）"><a href="#栈（stack）" class="header-anchor">#</a> 栈（Stack）</h2> <p>栈是一种 <strong>后进先出（LIFO，Last In First Out）</strong> 的数据结构，在 JavaScript 中，栈的实现要依赖于数组，换句话说就是 <strong>栈在 JavaScript 中是一种只用 pop 和 push 完成增删的数组</strong>。</p> <p>“后进先出“ 的特征限定了只能从数组的尾部进行操作，即 <code>pop</code> 用于删除尾部元素，<code>push</code> 用于在尾部添加元素。而另一个概念 “栈顶元素”，在这里表示的也就是数组的尾部元素。</p> <p>代码演示栈：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 初始状态，栈空</span>
<span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
<span class="token comment">// 入栈过程</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>

<span class="token comment">// 出栈过程，栈不为空时才执行</span>
<span class="token keyword">while</span><span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 单纯访问栈顶元素（不出栈）</span>
    <span class="token keyword">const</span> top <span class="token operator">=</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token comment">// 将栈顶元素出栈</span>
    stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 栈空</span>
stack <span class="token comment">// []</span>
</code></pre></div><h2 id="队列（queue）"><a href="#队列（queue）" class="header-anchor">#</a> 队列（Queue）</h2> <p>队列是一种 <strong>先进先出（FIFO，First In First Out）</strong> 的数据结构，与栈一样，队列的实现也要依赖数组，<strong>队列在 JavaScript 中是一种只用 shift 和 push 完成增删的数组</strong>。</p> <p>“先进先出” 的特征也很明显，就是在数组尾部用 <code>push</code> 添加元素，在数组头部用 <code>shift</code> 删除元素。</p> <p>代码演示队列：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>  
  
<span class="token keyword">while</span><span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 单纯访问队头元素（不出队）</span>
    <span class="token keyword">const</span> top <span class="token operator">=</span> queue<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token comment">// 将队头元素出队</span>
    queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 队空</span>
queue <span class="token comment">// []</span>
</code></pre></div><h2 id="链表"><a href="#链表" class="header-anchor">#</a> 链表</h2> <p>链表和数组类似，它们都是有序的列表，都是线性结构。不同点在于，链表中的数据单位的名称叫做 “结点”，结点和结点在内存中的分布是<strong>离散</strong>的。</p> <p>“离散”是相对于数组的“连续”来说的，数组在内存中是一段连续的内存空间，即元素与元素之间紧紧相连，每一个元素可以通过索引下标直接定位。</p> <p>链表中的元素与元素之间不像在数组中那样，哪怕知道了元素1的坑位，也不知道排在它后面的到底是谁，对于这种离散的内存状态，我们需要手动建立元素与元素之间的关联，让它们以线性排列。</p> <p>在链表中，每一个结点的结构都包括了两部分的内容：<strong>数据域</strong> 和 <strong>指针域</strong>。JS 中的链表，是以嵌套的对象的形式来实现：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token comment">// 数据域</span>
    val<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    <span class="token comment">// 指针域，指向下一个结点</span>
    next<span class="token operator">:</span> <span class="token punctuation">{</span>
        val<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
        next<span class="token operator">:</span> <span class="token operator">...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了线性关联。</p> <h3 id="链表结点的创建"><a href="#链表结点的创建" class="header-anchor">#</a> 链表结点的创建</h3> <p>使用构造函数创建结点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val
    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
node<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="插入链表结点"><a href="#插入链表结点" class="header-anchor">#</a> 插入链表结点</h3> <p>如果直接在尾部添加，那相对比较简单，就如上面代码一样，尾部结点的 next 指针指向新增的结点即可。这里考虑的是怎么在两个结点之间插入一个新的结点，假设已有两个结点：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 结点1</span>
<span class="token keyword">const</span> node1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">// 结点1的 next 指向结点2</span>
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>现在要在 node1 和 node2 之间插入 node3，本质上就是改变 node1 的 next 指向到 node3 上，而 node3 的 next 指向 node2，用代码表示即是：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 创建结点3</span>
<span class="token keyword">const</span> node3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token comment">// node1.next 指向的是 node2，现将 node2 挂到 node3.next 上</span>
node3<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">.</span>next
<span class="token comment">// node1.next 改为指向 node3</span>
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node3
</code></pre></div><p>现在它们的链接顺序就是 node1 -&gt; node3 -&gt; node2</p> <h3 id="删除链表结点"><a href="#删除链表结点" class="header-anchor">#</a> 删除链表结点</h3> <p>删除结点的本质是在遍历链表的过程中无法遍历到这个结点，按照这个逻辑，如果我们想要删除 node3，只要将 node1 的 next 跳过 node3，直接指向 node3 的后继，即指向 node2 就行了。如此一来，node3 就成了一个完全不可抵达的结点，它就会被 JS 的垃圾回收器自动回收掉。</p> <p>用代码演示删除 node3 的过程：</p> <div class="language-js extra-class"><pre class="language-js"><code>node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node3<span class="token punctuation">.</span>next
</code></pre></div><p>没错，就是这么简单。其实我们可以只用一个指针，这里我们只需要拿到 node1 即可：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// node1.next 本指向的就是 node3</span>
<span class="token keyword">const</span> target <span class="token operator">=</span> node1<span class="token punctuation">.</span>next
node1<span class="token punctuation">.</span>next <span class="token operator">=</span> target<span class="token punctuation">.</span>next
</code></pre></div><h2 id="链表和数组的辨析"><a href="#链表和数组的辨析" class="header-anchor">#</a> 链表和数组的辨析</h2> <p>首先要说的是“JS中的数组未必是真正的数组”。数组的定义中，有一个必要条件就是“存储在连续的内存空间里”，然而 JS 中的数组不一定满足这个条件。如果数组中只定义了一种类型的元素，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span>
</code></pre></div><p>它是一个纯数字数组，那么对应的确实是连续内存。
但如果定义了不同类型的元素：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">]</span>
</code></pre></div><p>它对应的就是一段非连续的内存。此时，JS 数组不再具有数组的特征，其底层其实是由链表来实现的。</p> <h3 id="访问效率对比"><a href="#访问效率对比" class="header-anchor">#</a> 访问效率对比</h3> <p>访问数组元素很简单，只需要拿到索引直接访问即可，如 <code>arr[2]</code>，这个操作的复杂度是常数级别的（O(1)）。但是访问链表结点时就比较麻烦了，当我们要读取某一个特定的结点时，需要遍历整个链表来查找它，比如要在一个长度为 n（n&gt;10）的链表里，定位它的第10个结点，就需要这样做：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 目标结点的位置</span>
<span class="token keyword">const</span> idx <span class="token operator">=</span> <span class="token number">10</span>
<span class="token comment">// 设一个游标指向链表第一个结点，从第一个结点开始遍历</span>
<span class="token keyword">let</span> node <span class="token operator">=</span> head 
<span class="token comment">// 反复遍历到第10个结点为止</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>index<span class="token operator">&amp;&amp;</span>node<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>next
<span class="token punctuation">}</span>
</code></pre></div><p>随着链表长度的增加，我们搜索的范围也会变大、遍历其中任意元素的时间成本自然随之提高。这个变化的趋势呈线性规律，用大 O 表示法表示为 O(n)。</p> <h3 id="增删效率对比"><a href="#增删效率对比" class="header-anchor">#</a> 增删效率对比</h3> <p>真正的数组都对应着一段连续的内存，如果要删除任意位置的一个元素，那么该元素后面的所有元素都要往前挪一个位置；相应地如果是添加元素，那么该元素后面的元素都要往后挪一个位置。</p> <p><strong>我们假设数组的长度是 n，那么因增加/删除操作导致需要移动的元素数量，就会随着数组长度 n 的增大而增大，呈一个线性关系。所以说数组增加/删除操作对应的复杂度就是 O(n)。</strong></p> <p>而在链表中，添加和删除操作的复杂度是固定的——不管链表里面的结点个数 n 有多大，只要我们明确了要插入/删除的目标位置，那么我们需要做的都仅仅是改变目标结点及其前驱/后继结点的指针指向。 因此我们说链表增删操作的复杂度是常数级别的复杂度，用大 O 表示法表示为 O(1)。</p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <p>二叉树是树形数据结构中的一种，它要满足以下要求：</p> <ul><li>它可以没有根节点，作为一棵空树存在</li> <li>如果不是空树，那么<strong>必须由根节点、左子树和右子树组成，且左右子树都是二叉树</strong>，如下图：
<img src="/awesome-record/algorithm/tree.png" alt="tree"></li></ul> <p><strong>二叉树不能被简单定义为每个结点的度都是2的树</strong>。二叉树中左右子树的位置是严格约定不能交换的，即 B 和 C、D 和 E、F 和 G 是不能互换的。</p> <blockquote><p>什么是度？一个结点开叉出去多少个子树，就被记为结点的“度”。二叉树中除了叶子结点，其他结点的度都为2。叶子结点表示的是没有开叉的结点。</p></blockquote> <h3 id="js-实现二叉树"><a href="#js-实现二叉树" class="header-anchor">#</a> JS 实现二叉树</h3> <p>在 JS 中，二叉树使用对象来定义，结构分为三部分：</p> <ul><li>数据域</li> <li>左侧子结点（左子树根结点）的引用</li> <li>右侧子结点（右子树根结点）的引用</li></ul> <p>使用构造函数方式定义二叉树：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token parameter">val</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>val <span class="token operator">=</span> val
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当需要创建二叉树结点时：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">6/2/2020, 4:59:16 PM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/awesome-record/algorithm/chapter2.html">
        遍历二叉树
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/awesome-record/assets/js/app.4bf2a835.js" defer></script><script src="/awesome-record/assets/js/2.0fcb112f.js" defer></script><script src="/awesome-record/assets/js/6.8680ebb7.js" defer></script>
  </body>
</html>
